問題は「SPAの“画面”は仕様→テスト→実装の写像が不安定になりやすい」のに、SpecKit入力（アーキ設計書・機能仕様・画面イメージ）をそのまま“コード生成”へ流してしまい、テストが“生成物の正しさの審判”として機能する前に、UI実装がブレるところにあります。

加えて、SPAのE2E（vite dev + MSW/モック + Playwright）をテストファーストで回すには、事前にテスト可能な境界（契約）をかなり強く設計しておかないと、テストがUI実装に引きずられて壊れやすくなります。

以下、典型的な失敗パターンの分析と、改善案（SpecKit + Copilotで回しやすい形）を提案します。

---

# 1) 何が起きているか（失敗の構造）

## A. 「画面イメージ」→「DOM構造」→「Playwrightテスト」が不安定

画面イメージや画面仕様からAIが生成するReactコンポーネントは、ちょっとした解釈差で以下がブレます。

- DOM構造（divの階層、labelの付け方）
- アクセシビリティ属性（role/name）
- state管理の粒度（local / store / URL同期）
- ルーティングやレイアウト構成

その結果、先に書いたE2Eが「本質ではないDOM差分」に引きずられて落ちます。

**テストが仕様の検証ではなく、実装の固定化（スナップショット化）になってしまう**のが根本問題です。

## B. テストファーストにしたいのに、テストの粒度が“いきなりE2E”になっている

SPAで「画面の動作確認」から入ると、テストは必然的に複合になります（router + store + fetch + UI）。

生成コードが少し変わるだけで失敗し、修正も広範囲になり、AIはまた別の形で直し…がループします。

## C. APIモックが“テストのための契約”になっていない

MSW等でモックしていても、次が曖昧だと安定しません。

- APIのスキーマ（request/response）とエラー形
- 画面状態遷移（loading/empty/error/success）の定義
- キャッシュ/再取得/リトライなどの規約

AIは「なんとなく動く」実装を作れても、**境界条件の網羅と整合**は崩れやすいです。

## D. “設計書が多い”ほど生成が安定するわけではない（入力が衝突する）

アーキ設計書・機能仕様・画面仕様・画面イメージが同時に入ると、AIは優先順位を誤りがちです。

- 仕様書Aでは Zustand、設計書Bでは Redux Toolkit
- 画面仕様ではバリデーション詳細があるのに、画面イメージからは読み取れない
- 命名規約、コンポーネント分割方針が一致していない

入力がリッチでも、**「規約（決め）」として一枚に収束していない**とブレます。

# 2) 改善の方向性（結論）

SPAの仕様駆動開発を安定させるには、テストファーストを

- 契約（Contract）テスト
- ロジック（ドメイン/アプリ層）単体テスト
- UIのコンポーネントテスト（Playwright CT or Testing Library）
- 最小限のE2E（本当に重要な1〜3経路のみ）

の順に“積み上げ”に変え、E2Eを「最後の薄い確認」に落とすのが最も効きます。

そのためにSpecKit入力も「仕様書の束」ではなく、**生成を固定する“規約 + 契約 + 状態遷移”中心**に再構成するのがポイントです。

# 3) 具体的な改善案（実行プラン）

## 3.1 SpecKit入力を「生成がブレない形」に再設計する

画面仕様・画面イメージは有用ですが、コード生成の安定化には次を優先して入力に含めるべきです。

### (1) UI規約（Design & Coding Rules）を明文化

- 採用ライブラリ（例：React Router / TanStack Query / Zod / MUI 等）を固定
- フォルダ構成、命名、コンポーネント分割のルール
- stateの置き場所（URL / QueryCache / local state / global store）
- アクセシビリティ方針（role/name、フォームのlabel必須等）

### (2) “画面ごとの状態遷移表”を仕様として入れる

- loading / success / empty / validation error / server error
- 表示メッセージ、ボタン活性、リトライ可否
- これがあると、テストがDOMではなく“状態”を検証できる

### (3) API契約をOpenAPI or JSON Schemaで固定

- request/response/エラーの型
- 例外系（409/422/500）を必ず定義<BR>
  → MSWモックもそこから生成/同期しやすくなります。

画面イメージは「見た目のガイド」で、テストの基準にしない（テストは状態と契約に寄せる）。

## 3.2 テスト戦略を「E2E中心」から「契約・状態中心」へ移す

レイヤ別の“テストファースト対象”をはっきり分ける

### A. ドメイン/アプリ層（純粋ロジック）

- Vitestでテストファーストが最もやりやすい<BR>
  例：入力→バリデーション→コマンド生成→状態遷移、など
- Reactを極力通さない（副作用はinterface越し）

### B. APIクライアント層

- Contract test（OpenAPIに対する型整合、エラーパース）を先に作る
- MSWは「契約の実装」扱いにして、画面ごとにバラバラなハンドラを書かない

### C. UI

- まずはコンポーネントテスト（Testing Library or Playwright Component Testing）で
  - 主要な状態（loading/error/empty/success）
  - 主要なユーザー操作（入力→submit→結果） を確認する
- **E2Eは“配線確認”に限定**（ログイン〜主要1経路、など）

こうすると、AIがUI構造を少し変えても、ロジックと契約が守られていれば大崩れしません。

### 3.3 Playwright E2Eを安定させるためのコツ（DOM依存を減らす）

E2Eが不安定な最大要因はセレクタです。次を仕様として固定すると効果が大きいです。

- data-testid ではなく、基本は role/name（a11y）で取る
- どうしても必要な箇所だけ data-testid を許可（規約に明記）
- 画面ごとに「テスト用の安定ID一覧」を仕様に含める<BR>
  例：[data-testid="user-create-submit"] のように用途ベースで命名

また、E2Eで「画面の細部」を検証しないで、**ユーザー価値の完了条件**に絞ります
（例：作成できる、一覧に出る、エラーが出る）。

### 3.4 生成を安定させる “実装の骨格” を先に人間が固定する

SpecKit + Copilotに任せきるより、最初に以下だけ人間が作って固定すると、その後の生成品質が安定します。

- ルーティング骨格（ページ一覧とレイアウト枠）
- UIコンポーネントのベース（フォーム、ダイアログ、テーブル等の共通部品）
- APIクライアントの型・エラーモデル（ApiError の共通形）
- 状態管理の方式（Query中心なのか、Store中心なのか）

AIに任せるのは「各機能の実装差分」に寄せるのがコツです。

## 4) おすすめの進め方（1スプリント目の手順例）

1. **契約：** OpenAPI/Schema確定 → そこから型生成 or 手書きでも固定
1. **MSW：** 契約に沿ったハンドラ雛形を用意（success/error両方）
1. **状態遷移表：** 主要画面だけ先に作る（最低でも成功/失敗/空）
1. **ロジック単体テスト：** ユースケース/バリデーションをVitestで先に
1. **UIコンポーネントテスト：** 状態ごとの表示と主要操作
1. **E2E：** 最重要経路だけ（1〜3本）

以降、機能追加はこの順で増やす
